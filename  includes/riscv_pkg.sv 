package riscv_pkg;
  import uvm_pkg::*;  // UVM import for testbench components

  // =============================================
  // RISC-V 32-bit Memory Instruction Configuration
  // =============================================
  parameter XLEN          = 32;       // Register width (32-bit)
  parameter MEM_ADDR_SIZE = XLEN;     // Memory address space
  parameter MEM_ALIGNMENT = 4;        // 4-byte alignment for LW/SW

  // =============================================
  // Memory Instruction Opcodes and Function Codes
  // =============================================
  typedef enum logic [6:0] {
    OP_LOAD  = 7'b0000011,  // Load Word (LW)
    OP_STORE = 7'b0100011   // Store Word (SW)
  } mem_opcode_t;

  typedef enum logic [2:0] {
    FUNCT3_LW_SW = 3'b010   // funct3 code for both LW and SW
  } mem_funct3_t;

  // =============================================
  // Instruction Format Structures
  // =============================================
  typedef struct packed {
    logic [11:0] imm;      // 12-bit offset
    logic [4:0]  rs1;      // Base register
    logic [2:0]  funct3;   // FUNCT3_LW_SW
    logic [4:0]  rd;       // Destination (LW only)
    logic [6:0]  opcode;   // OP_LOAD
  } lw_instr_t;            // I-type format for LW

  typedef struct packed {
    logic [6:0]  imm_hi;   // Offset[11:5]
    logic [4:0]  rs2;      // Source register
    logic [4:0]  rs1;      // Base register
    logic [2:0]  funct3;   // FUNCT3_LW_SW
    logic [4:0]  imm_lo;   // Offset[4:0]
    logic [6:0]  opcode;   // OP_STORE
  } sw_instr_t;            // S-type format for SW

  // =============================================
  // Memory Verification Utilities
  // =============================================
  // Checks 4-byte alignment for memory operations
  function automatic logic is_mem_aligned(logic [XLEN-1:0] addr);
    return (addr % MEM_ALIGNMENT == 0);
  endfunction

  // Generates valid LW instruction
  function automatic lw_instr_t gen_lw_instr(
    input logic [4:0]  rd,
    input logic [4:0]  base_reg,
    input logic [11:0] offset
  );
    return '{
      imm:    offset,
      rs1:    base_reg,
      funct3: FUNCT3_LW_SW,
      rd:     rd,
      opcode: OP_LOAD
    };
  endfunction

  // Generates valid SW instruction
  function automatic sw_instr_t gen_sw_instr(
    input logic [4:0]  base_reg,
    input logic [4:0]  src_reg,
    input logic [11:0] offset
  );
    return '{
      imm_hi: offset[11:5],
      rs2:    src_reg,
      rs1:    base_reg,
      funct3: FUNCT3_LW_SW,
      imm_lo: offset[4:0],
      opcode: OP_STORE
    };
  endfunction

  // =============================================
  // Memory Transaction Type for UVM
  // =============================================
  typedef struct {
    logic [XLEN-1:0] address;
    logic [XLEN-1:0] data;
    logic            is_load;  // 1=load, 0=store
    logic [2:0]      size;     // 2=word(4B), 1=halfword, 0=byte
  } mem_transaction_t;

endpackage